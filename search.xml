<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[归并排序为什么要用败者树？]]></title>
    <url>%2F2020%2F05%2F15%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E8%B4%A5%E8%80%85%E6%A0%91%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[https://www.zhihu.com/question/35144290/answer/148681658 堆排序的时间复杂度跟败者树的时间复杂度一致为什么不用堆？$O(nklog_k(n) + k) =O(nklog_kn)$ 其实一开始就是用堆来完成多路归并的，但是人们发现堆每次取出最小值之后，把最后一个数放到堆顶，调整堆的时候，每次都要选出父节点的左右两个孩子节点的最小值，然后再用孩子节点的最小值和父节点进行比较，所以每调整一层需要比较两次。 这时人们想能否简化比较过程，这时就有了胜者树。 这样每次比较只用跟自己的兄弟节点进行比较就好，所以用胜者树可以比堆少一半的比较次数。 而胜者树在节点上升的时候首先需要获得父节点，然后再获得兄弟节点，然后再比较。这时人们又想能否再次减少比较次数，于是就有了败者树。 在使用败者树的时候，每个新元素上升时，只需要获得父节点并比较即可。 所以总的来说，减少了访存的时间。（拿空间换时间） 原因：胜者树以小为胜的话，如果比较兄弟节点发现更小直接替代父节点即可，如果更大则兄弟节点胜出。败者树比较父节点指向的点发现更大直接替换败者即可，更小则不需要替换然后接着上移。 二者都是顶点缺失，都要从底部叶节点遍历到顶点。 最后就是现在程序的主要瓶颈在于访存了，计算倒几乎可以忽略不计。]]></content>
  </entry>
  <entry>
    <title><![CDATA[置换-选择排序]]></title>
    <url>%2F2020%2F05%2F15%2F-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[http://data.biancheng.net/view/78.html 如果内存为W，则内排序算法最多只能对大小略小于W的段进行排序。置换-选择排序可以降低段的个数 置换—选择排序算法的具体操作过程为： 首先从有24个记录的初始文件中输入 6 个记录到内存工作区中；从内存工作区中选出关键字最小的记录，将其记为 MINIMAX 记录；然后将 MINIMAX 记录输出到归并段文件中； 此时内存工作区中还剩余 5 个记录，若初始文件不为空，则从初始文件中输入下一个记录到内存工作区中； 从内存工作区中的所有比 MINIMAX 值大的记录中选出值最小的关键字的记录，作为新的 MINIMAX 记录； 重复过程 3—5，直至在内存工作区中选不出新的 MINIMAX 记录为止，由此就得到了一个初始归并段； 重复 2—6，直至内存工作为空，由此就可以得到全部的初始归并段。 123456789101112131415161718192021222324514939463829146115301485238327413892446583376 具体步骤： 首先输入前 6 个记录到内存工作区，其中关键字最小的为 29，所以选其为 MINIMAX 记录，同时将其输出到归并段文件中，如下图所示： 2.此时初始文件不为空，所以从中输入下一个记录 14 到内存工作区中，然后从内存工作区中的比 29 大的记录中，选择一个最小值作为新的 MINIMAX 值输出到 归并段文件中，如下图所示： 3.初始文件还不为空，所以继续输入 61 到内存工作区中，从内存工作区中的所有关键字比 38 大的记录中，选择一个最小值作为新的 MINIMAX 值输出到归并段文件中，如下图所示： 4.如此重复性进行，直至选不出 MINIMAX 值为止，如下图所示： 5.当选不出 MINIMAX 值时，表示一个归并段已经生成，则开始下一个归并段的创建，创建过程同第一个归并段一样，这里不再赘述。 败者树的实现： 在不断选择新的 MINIMAX 记录时，为了防止新加入的关键字值小的的影响，每个叶子结点附加一个序号位，当进行关键字的比较时，先比较序号，序号小的为胜者；序号相同的关键字值小的为胜者。 在初期创建败者树时也可以通过不断调整败者树的方式，其中所有记录的序号均设为 0 ，然后从初始文件中逐个输入记录到内存工作区中，自下而上调整败者树。过程如下： 1.首先创建一个空的败者树，如下图所示： 2.从初始文件中读入关键字为 51 的记录，自下往上调整败者树，如下图所示： 提示：序号 1 默认为比 0 小，为败者。 3.从初始文件中读入关键字为 49 的记录，调整败者树如下图所示： 4.从初始文件依次读入关键字为 39、46、38、29 的记录，调整败者树如下图所示： 5.由败者树得知，其最终胜者为 29，设为 MINIMAX 值，将其输出到初始归并文件中，同时再读入下一个记录 14，调整败者树，如下图所示： 通过不断地向败者树中读入记录，会产生多个 MINIMAX，直到最终所有叶子结点中的序号都为 2，此时产生的新的 MINIMAX 值的序号 2（循环判定胜者的段号决定是否输出新段），表明此归并段生成完成，而此新的 MINIMAX 值就是下一个归并段中的第一个记录。 注意：当读入新的记录时，如果其值比 MINIMAX 大，其序号则仍为 1；反之则为 2 ，比较时序号大的。 总结： 通过置换选择排序算法得到的初始归并段，其长度并不会受内存容量的限制，且通过证明得知使用该方法所获得的归并段的平均长度为内存工作区大小的两倍。 若不计输入输出的时间，通过置换选择排序生成初始归并段的所需时间为O(nlogw)（其中 n 为记录数，w 为内存工作区的大小）。 以下代码有问题，有时候会多生成几个数，但是可以拿来做个参考。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#define MAXKEY 10000#define RUNEND_SYMBOL 10000 // 归并段结束标志#define w 6 // 内存工作区可容纳的记录个数#define N 24 // 设文件中含有的记录的数量typedef int KeyType; // 定义关键字类型为整型// 记录类型typedef struct&#123; KeyType key; // 关键字项&#125;RedType;typedef int LoserTree[w];// 败者树是完全二叉树且不含叶子，可采用顺序存储结构typedef struct&#123; RedType rec; /* 记录 */ KeyType key; /* 从记录中抽取的关键字 */ int rnum; /* 所属归并段的段号 */&#125;RedNode, WorkArea[w];// 从wa[q]起到败者树的根比较选择MINIMAX记录，并由q指示它所在的归并段void Select_MiniMax(LoserTree ls,WorkArea wa,int q)&#123; int p, s, t;// ls[t]为q的双亲节点，p作为中介 for(t = (w+q)/2,p = ls[t]; t &gt; 0;t = t/2,p = ls[t])&#123; // 段号小者 或者 段号相等且关键字更小的为胜者 if(wa[p].rnum &lt; wa[q].rnum || (wa[p].rnum == wa[q].rnum &amp;&amp; wa[p].key &lt; wa[q].key))&#123; s=q; q=ls[t]; //q指示新的胜利者 ls[t]=s; &#125; &#125; ls[0] = q; // 最后的冠军&#125;//输入w个记录到内存工作区wa,建得败者树ls,选出关键字最小的记录，并由s指示其在wa中的位置。void Construct_Loser(LoserTree ls, WorkArea wa, FILE *fi)&#123; int i; for(i = 0; i &lt; w; ++i)&#123; wa[i].rnum = wa[i].key = ls[i] = 0; &#125; for(i = w - 1; i &gt;= 0; --i)&#123; fread(&amp;wa[i].rec, sizeof(RedType), 1, fi);// 输入一个记录 wa[i].key = wa[i].rec.key; // 提取关键字 wa[i].rnum = 1; // 其段号为＂1＂ Select_MiniMax(ls,wa,i); // 调整败者树 &#125;&#125;// 求得一个初始归并段，fi为输入文件指针，fo为输出文件指针。void get_run(LoserTree ls,WorkArea wa,int rc,int *rmax,FILE *fi,FILE *fo)&#123; int q; KeyType minimax; // 选得的MINIMAX记录属当前段时 while(wa[ls[0]].rnum == rc)&#123; q = ls[0];// q指示MINIMAX记录在wa中的位置 minimax = wa[q].key; // 将刚选得的MINIMAX记录写入输出文件 fwrite(&amp;wa[q].rec, sizeof(RedType), 1, fo); // 如果输入文件结束，则虚设一条记录（属＂rmax+1＂段） if(feof(fi))&#123; wa[q].rnum = *rmax+1; wa[q].key = MAXKEY; &#125;else&#123; // 输入文件非空时 // 从输入文件读入下一记录 fread(&amp;wa[q].rec,sizeof(RedType),1,fi); wa[q].key = wa[q].rec.key;// 提取关键字 if(wa[q].key &lt; minimax)&#123; // 新读入的记录比上一轮的最小关键字还小，则它属下一段 *rmax = rc+1; wa[q].rnum = *rmax; &#125;else&#123; // 新读入的记录大则属当前段 wa[q].rnum = rc; &#125; &#125; // 选择新的MINIMAX记录 Select_MiniMax(ls, wa, q); &#125;&#125;//在败者树ls和内存工作区wa上用置换－选择排序求初始归并段void Replace_Selection(LoserTree ls, WorkArea wa, FILE *fi, FILE *fo)&#123; int rc, rmax; RedType j; j.key = RUNEND_SYMBOL; // 初建败者树 Construct_Loser(ls, wa, fi); rc = rmax =1;//rc指示当前生成的初始归并段的段号，rmax指示wa中关键字所属初始归并段的最大段号 while(rc &lt;= rmax)&#123;// ＂rc=rmax+1＂标志输入文件的置换－选择排序已完成 // 求得一个初始归并段 get_run(ls, wa, rc, &amp;rmax, fi, fo); fwrite(&amp;j,sizeof(RedType),1,fo);//将段结束标志写入输出文件 rc = wa[ls[0]].rnum;//设置下一段的段号 &#125;&#125;void print(RedType t)&#123; printf(&quot;%d &quot;,t.key);&#125;int main()&#123; RedType a[N]=&#123;51,49,39,46,38,29,14,61,15,30,1,48,52,3,63,27,4,13,89,24,46,58,33,76&#125;; RedType b; FILE *fi,*fo; //输入输出文件 LoserTree ls; // 败者树 WorkArea wa; // 内存工作区 int i, k; fo = fopen(&quot;ori&quot;,&quot;wb&quot;); //准备对 ori 文本文件进行写操作 //将&lt;u&gt;[数组](http://data.biancheng.net/view/181.html)&lt;/u&gt; a 写入大文件orifwrite(a, sizeof(RedType), N, fo); fclose(fo); //关闭指针 fo 表示的文件 fi = fopen(&quot;ori&quot;,&quot;rb&quot;);//准备对 ori 文本文件进行读操作 printf(&quot;文件中的待排序记录为:\n&quot;); for(i = 1; i &lt;= N; i++)&#123; // 依次将文件ori的数据读入并赋值给b fread(&amp;b,sizeof(RedType),1,fi); print(b); &#125; printf(&quot;\n&quot;); rewind(fi);// 使fi的指针重新返回大文件ori的起始位置，以便重新读入内存，产生有序的子文件。 fo = fopen(&quot;out&quot;,&quot;wb&quot;); // 用置换－选择排序求初始归并段 Replace_Selection(ls, wa, fi, fo); fclose(fo); fclose(fi); fi = fopen(&quot;out&quot;,&quot;rb&quot;); printf(&quot;初始归并段各为:\n&quot;); do&#123; k = fread(&amp;b, sizeof(RedType), 1, fi); //读 fi 指针指向的文件，并将读的记录赋值给 b，整个操作成功与否的结果赋值给 k if(k == 1)&#123; if(b.key ==MAXKEY)&#123;//当其值等于最大值时，表明当前初始归并段已经完成 printf(&quot;\n\n&quot;); continue; &#125; print(b); &#125; &#125;while(k == 1); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[外部排序]]></title>
    <url>%2F2020%2F05%2F15%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[http://data.biancheng.net/view/77.html 多路归并排序： 对于外部排序算法来说，影响整体排序效率的因素主要取决于读写外存的次数，即访问外存的次数越多，算法花费的时间就越多，效率就越低。 对于同一个文件来说，对其进行外部排序时访问外存的次数同归并的次数成正比，即归并操作的次数越多，访问外存的次数就越多（每次归并都要加载硬盘上的待归并文件到内存）。 最后一轮归并的时候内存不够怎么办？ 在实际归并的过程中，由于内存容量的限制不能满足同时将 2 个归并段全部完整的读入内存进行归并，只能不断地取 2 个归并段中的每一小部分进行归并，通过不断地读数据和向外存写数据，直至 2 个归并段完成归并变为 1 个大的有序文件。 有关段的预处理如何提升算法效率？ 对比2-路还有5-路归并排序可以看出，对于 k-路平衡归并中，增加 k 可以减少归并的次数，从而减少外存读写的次数，最终达到提高算法效率的目的。除此之外，一般情况下对于具有 m 个初始归并段进行 k-路平衡归并时，归并的次数为：$s=⌊log_k⁡m ⌋$（其中 s 表示归并次数） -方法也就以下两个：（1）增加 k-路平衡归并中的 k 值；（多路平衡归并算法）（2）减少初始段的数量m / 增加每个归并段的容量（段太大的话内存可能不够）；（置换-选择排序算法）]]></content>
      <categories>
        <category>分布式与并行计算</category>
      </categories>
      <tags>
        <tag>分布式与并行计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成员初始化的顺序]]></title>
    <url>%2F2020%2F05%2F05%2Ftest%2F</url>
    <content type="text"><![CDATA[可以看出成员被初始化的顺序和成员初始化表里面的顺序是没有关系的，只和成员的声明顺序有关。 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int seti() &#123;cout &lt;&lt; &quot;seti&quot; &lt;&lt; endl;return 1;&#125;int setj() &#123;cout &lt;&lt; &quot;setj&quot; &lt;&lt; endl;return 1;&#125;class a&#123;public: a() &#123;cout &lt;&lt; &quot;a()~~~~~&quot; &lt;&lt; endl;&#125;&#125;;class b&#123;public: b():j(setj()),i(seti()) &#123;cout &lt;&lt; &quot;b()~~~~~&quot; &lt;&lt; endl;&#125; int i; a ca; int j;&#125;;int main()&#123; b ob; return 0;&#125; 构造函数执行顺序：public里面 int i 先声明，就先构造 i，然后类a ca 声明，再构造 ca，然后声明 j，就构造 j，最后执行 b() 构造函数里面的东西。 另外举个例子：12345678910111213141516171819#include &lt;iostream&gt;using namespace std;class A&#123;private: int n1; int n2;public: A():n2(0),n1(n2+2)&#123;&#125; void Print()&#123; cout &lt;&lt; &quot;n1:&quot; &lt;&lt; n1 &lt;&lt; &quot;, n2: &quot; &lt;&lt; n2 &lt;&lt;endl; &#125;&#125;;int main()&#123; A a; a.Print(); return 1;&#125; 因为private里面先定义的n1再定义的n2，但是n1需要n2，n2没有初始化，所以n2是乱码，n1是0。]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拉格朗日乘子法和（对偶性与KKT条件）]]></title>
    <url>%2F2019%2F10%2F14%2F%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E5%AD%90%E6%B3%95%E5%92%8C%EF%BC%88%E5%AF%B9%E5%81%B6%E6%80%A7%E4%B8%8EKKT%E6%9D%A1%E4%BB%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[https://blog.csdn.net/weixin_37688445/article/details/79275526https://www.matongxue.com/madocs/939.htmlhttps://www.matongxue.com/madocs/987/ 拉格朗日乘子法（约束条件为等式） $\begin{cases}min f(x) \\\h_i(x)=0，i=0，1，…，n\end{cases}$ 在两个图线外相切的时候达到最小值，法向量方向相反 $\begin{cases}\nabla f(x)=-\nabla \lambda\star h_i(x) =&gt; \nabla f(x)+\nabla \lambda\star h_i(x)=0\\\h_i(x)=0，i=0，1，…，n\end{cases}$ 最终表达式： $\begin{cases}L(x,a)=min[f(x)+\sum_{i=1}^{n}a_ih_i(x)]\\h_i(x)=0，i=0，1，…，n\end{cases}$ 求解：$\nabla_xL(x,a)=0$还有$\nabla_aL(x,a)=0$可得最优解的x和a 拉格朗日的KKT条件 初试条件： $\begin{cases}min f(x) \\\g(x) &lt;= 0\end{cases}$ 推导出来的最终公式： $\begin{cases}式1： L(x,a)=min[f(x)+\lambda*g(x)]\\式2： g(x) = 0 \\式3：\lambda&gt;0\end{cases}$ *情况1： 如果可行解直接落在约束条件范围内，即落在g(x)&lt;0的范围内，则直接删掉约束条件即可。（但是最优点依旧满足前提：公式1即使两条线在$r_f$≈0的时候不相交） *情况2：如果可行解落在约束条件外，则最优解在边界上去的，即在g(x)=0的曲线上取得。（此时转换为前面讲的等式条件下求最优解的问题，直接套上面的公式） 以上两种状况要么落在约束区域内，则$\lambda_解$=0，因为直接去掉约束条件即可，要么落在约束条件边界上，则$g(x)_解=0$, 综合起来就是$\lambda*g(x)=0$ 还有一个问题就是$\lambda$的取值问题，当$\lambda$不等于0的时候，即最优解在$g(x)=0$上取得时，$f(x,y)$梯度方向必须要和$g(x)=0$的梯度方向相反，即$-\nabla_xf(x)=\lambda\nabla_xg(x)$，所以$\lambda$一定大于0，要不然就恒非零了。 拉格朗日对偶性：（$\lambda$改为a表示） 1.原始最优化问题： $\begin{cases}式1： \min_{x \in R^n} f(x)\\式2： c_i(x)&lt;=0 ， i=1，2，…，k \\式3：h_j(x)=0 ，j=1，2，…，l\end{cases}$ $L(x,a,\beta)=f(x)+\sum_{i=1}^{k}a_ic_i(x)+\sum_{j=1}^{l}\beta_jh_j(x)$ 2.极小极大问题： $令\theta_P(x)=\max_{a,\beta:a_i&gt;=0}L(x,a,\beta)$ 如果$i$和$j$当中有一个不满足式2/式3条件，那么必然存在某个$i$满足$c_i(x)&gt;0$，可令$a_i-&gt;+\infty$，或者存在某个$j$满足$h_j(x) \ne 0$，则可令$\beta_jh_j(x)\rightarrow +\infty$，而将其余各个$a_i$，$\beta_j$均取为$0$，使得$\theta_P(x)=+\infty$ 所以max化的拉格朗日函数 $\theta_P(x)=\begin{cases}f(x) ， x满足原始问题约束\\+\infty ， 其他\end{cases}$ 接着考虑max条件下的min最优值： p^*=min \theta_P(x)=\min_{x} \max_{a,\beta:a_i>=0} L(x,a,\beta) 3.极大极小问题： $\max_{a,\beta}\theta_D(a,\beta)=\max_{a,\beta}\min_{x}L(x,a,\beta)，a_i&gt;=0$ 最优解：$d^*=\max_{a,\beta:a_i&gt;=0}\theta_D(a,\beta)$ 4.极大极小问题与极小极大问题的解什么时候相等？ maxmin和minmax的最优解有以下大小关系： d^*=\max_{a,\beta:a_i>=0}\min_{x}L(x,a,\beta)=0} L(x,a,\beta)=p^*如果满足$f(x)$和$c_i(x)$是凸函数，$h_j(x)$是仿射函数，和KKT条件，则： d^*=L(x^*,a^*,\beta^*)=p^*KKT条件是$d^\star$ = $p^\star$的充要条件： \nabla_xL(x^*,a^*,\beta^*)=0a_i^*c_i(x^*)=0，i=1,2,...,kc_i(x^*)=0 ， i=1,2,...,kh_j(x^*)=0，j=1，...，l]]></content>
  </entry>
  <entry>
    <title><![CDATA[VC维]]></title>
    <url>%2F2019%2F10%2F12%2FC%E7%BB%B4%2F</url>
    <content type="text"><![CDATA[VC 维是衡量函数类的复杂度的一种方式，通过评估函数类中函数的弯曲程度实现。WIKI上的解释是：空间中的点在经过排列之后，能够被模型f打散(shatter)的最大数量。 通过$y=a_0+a_1^Tx$将平面分割为两部分，如果满足平面中任意N个点（无论如何取值）总能被一条直线分开，而N+1个点却不行，则称该函数情况下的VC维为N。 举个无穷的VC维的例子： f(x,a)=I(sina*x) 从这两个例子，可以看出VC维刻画了函数的弯曲程度，越弯曲其VC维越大。]]></content>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的几种决策树]]></title>
    <url>%2F2019%2F10%2F12%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%B3%E7%AD%96%E6%A0%91%2F</url>
    <content type="text"><![CDATA[https://www.cnblogs.com/pinard/p/6053344.htmlhttps://blog.csdn.net/a857553315/article/details/95620881 特征选择：如果瞎猜中的概率与特征选择出来的概率相差无几，那么就可以放弃该特征了。特征选择的标准是信息增益或信息增益比。 ID3算法与信息增益：（木有剪枝，只能处理离散数据） 得知特征X的信息而使输出的分类Y的不确定性减少的程度。 条件熵：$H(Y|X)=\sum_{n}^{i=1}p_iH(Y|X=x_i)$ 信息增益：$g(D,A)=H(D)-H(D|A)$，D是数据集，A是特征。 计算过程：（1）计算数据集D的经验熵： $H(D)=-\sum_{k=1}^{K}\frac{|C_k|}{|D|}log_2\frac{|C_k|}{|D|}$ ，k为第一级特征{纹理，色泽，触感} （2）计算条件熵： $H(D|A)=\sum_{i=1}^{n}\frac{|D_i|}{D}H(D_i)=\sum_{i=1}^{n}\frac{|D_i|}{|D|}\sum_{k=1}^{K}\frac{|D_{ik}|}{D_i}log_2\frac{|D_{ik}|}{|D_i|}$ i为第一级特征{ 纹理 / 色泽 / 触感 }，ik为纹理中的第二级特征{ 清晰，模糊，稍糊 } （3）$g(D,A)=H(D)-H(D|A)$，越大越好。 ID3算法就是完全依赖信息增益，但是信息增益明显对多个取值的特征有偏好，所以出现了使用增益率的C4.5算法。 C4.5算法与增益率（后剪枝，可以处理连续数据—&gt;多叉树，特征要计算排序） $Gainratio(D,a)=\frac{Gain(D,a)}{IV(a)}$ 固有值：$IV(a)=-\sum_{v=1}^{V}\frac{|D_v|}{|D|}log_2\frac{|D_v|}{|D|}$ ，Dv是第一级特征a下的第二级特征，固有值随V的个数增加而增加。 CART决策树（减少log的使用降低计算量，还可以用于回归，二叉树） 使用Gini系数替代ID3里的熵，Gini系数越小越均衡（被错分的概率低），说明该样本只属于同一类的概率（纯度）越高。 $Gini(D)=\sum_{k=1}^{y}\sum_{k’ \ne k}p_k*p_k’=1-\sum_{k=1}^{y}p_k^2$ pk表示选中的样本属于k类别的概率，则这个样本被分错的概率是(1-pk) 基尼指数（基尼不纯度）= 样本被选中的概率 * 样本被分错的概率 预剪枝与后剪枝：（对抗过拟合与欠拟合） 预剪枝：（边自上往下生成枝杈边剪枝） 预剪枝使得很多分支没有展开，这不仅降低了过拟合的风险，还显著减少了决策树的训练时间开销和测试时间。但是，有些分支虽当前不能提升泛化性。甚至可能导致泛化性暂时降低，但在其基础上进行后续划分却有可能导致显著提高，因此预剪枝的这种贪心本质，给决策树带来了欠拟合的风险。 后剪枝：（先生成枝桠，最后从下往上剪枝） 后剪枝通常比预剪枝保留更多的分支，其欠拟合风险很小，因此后剪枝的泛化性能往往优于预剪枝决策树。但后剪枝过程是从底往上裁剪，因此其训练时间开销比前剪枝要大。 连续值处理：（密度/甜度）连续（非离散）特征可以将特征值从小到大排列然后取 T_a={\frac{a_i+a_{i+1}}{2},0]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传教士和野人问题（M-C问题）]]></title>
    <url>%2F2019%2F10%2F12%2F%E4%BC%A0%E6%95%99%E5%A3%AB%E5%92%8C%E9%87%8E%E4%BA%BA%E9%97%AE%E9%A2%98%EF%BC%88M-C%E9%97%AE%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[有N个传教士和N个野人来到河边渡河，河岸有一条船，每次至多可供k人乘渡。河两岸以及船上的野人数目总是不超过传教士的数目(否则不安全，传教士有可能被野人吃掉)。即求解传教士和野人从左岸全部摆渡到右岸的过程中，任何时刻满足M(传教士数)≥C(野人数)和M+C≤k的摆渡方案。以下讨论三个传教士三个野人还有一条船最多能载两个人的方案。 状态空间 我们用一个三元组(m，c，b)来表示河岸上的状态，其中m、c分别代表某一岸上传教士与野人的数目，b=1表示船在这一岸，b=0则表示船不在 约束条件是: 两岸上M≥C, 船上M+C≤2 （mi，ci）为船上的传教士和野人数量 左岸初态为（3,3,1），终态为（0,0,0） 为什么不能直接暴力穷举然后剪枝？ 因为可能运过去两个人，然后又把同样的两个人运回来了(或者使用别的形式但是依旧是空转)，所以要杜绝这种可能，当然最好的方法就是使用带有记忆的状态，如果之前遇到过这种状态那就拒绝执行return。 所以….如何实现去重的目标？？？ 答：set，我采取的是单个状态采用int，记录路径经过的状态采用string（中间用空格隔开） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;string&gt;#include&lt;set&gt;#include&lt;vector&gt;using namespace std;int N;set&lt;string&gt;ans;void print(vector&lt;int&gt;way)&#123; int i=0; string h; for(i=1;i&lt;way.size();i++)&#123; printf(&quot;%03d &quot;,way[i]); if(way[i]&lt;100)&#123; h+=&quot;0&quot;; &#125; h+=to_string(way[i]); h+=&quot; &quot;; &#125; cout&lt;&lt;&quot;\n-------&quot;&lt;&lt;endl; ans.insert(h);&#125;void dfs(int pre,int ni,int nj,int c,set&lt;int&gt;s,vector&lt;int&gt;way)&#123; // set insert int now=ni*100+nj*10+c; s.insert(pre); if(s.count(now)||(N-ni)&lt;0||(N-nj)&lt;0||ni&lt;0||nj&lt;0||(ni&lt;nj&amp;&amp;ni!=0)||((N-ni)&lt;(N-nj)&amp;&amp;(N-ni)!=0))&#123; return; &#125; if(pre==0)&#123; // 如果上一轮就截止了 print(way); return; &#125; way.push_back(pre); if(c==1)&#123; // zero people . no one on ship is illegal // dfs(now,ni,nj,0,s,way); // one people on dfs(now,ni-1,nj,0,s,way); dfs(now,ni,nj-1,0,s,way); // two people on dfs(now,ni-2,nj,0,s,way); dfs(now,ni,nj-2,0,s,way); dfs(now,ni-1,nj-1,0,s,way); &#125; else&#123; // zero people . no one on ship is illegal // dfs(now,ni,nj,1,s,way); // one people on dfs(now,ni+1,nj,1,s,way); dfs(now,ni,nj+1,1,s,way); // two people on dfs(now,ni+2,nj,1,s,way); dfs(now,ni,nj+2,1,s,way); dfs(now,ni+1,nj+1,1,s,way); &#125;&#125;int main()&#123; int chooseN; int c=1; // init num and ship side 1 means left and 0 means right int ni,nj; // Ni(传教士),Nj(野人) on the left side. int pre=-1; set&lt;int&gt;s; //cin&gt;&gt;chooseN; chooseN=3; N=nj=ni=chooseN; vector&lt;int&gt;way; dfs(pre,ni,nj,c,s,way); cout&lt;&lt;&quot;\nfinally , the answer is:\n\n&quot;; for(auto it=ans.begin();it!=ans.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;endl; &#125;&#125;/*331 310 321 300 311 110 221 020 031 010 111 -------331 310 321 300 311 110 221 020 031 010 111 -------331 310 321 300 311 110 221 020 031 010 021 -------331 310 321 300 311 110 221 020 031 010 021-------331 220 321 300 311 110 221 020 031 010 111-------331 220 321 300 311 110 221 020 031 010 111 -------331 220 321 300 311 110 221 020 031 010 021-------331 220 321 300 311 110 221 020 031 010 021-------finally , the answer is:331 220 321 300 311 110 221 020 031 010 021331 220 321 300 311 110 221 020 031 010 111331 310 321 300 311 110 221 020 031 010 021331 310 321 300 311 110 221 020 031 010 111*/ 传说中的基于A*算法的解法：评估函数的建立： f=d+h=d+M+N-2*BM 表示左岸的传教士的人数，N 表示左岸野人的数目，B 取值为0或1 ，1 表示船在左岸，0 表示船在右岸。d 表示节点的深度。 下面我们来证明h(n)＝M+C-2B是满足A*条件的： 我们分两种情况考虑。（1）先考虑船在左岸的情况。如果不考虑限制条件，也就是说，船一次可以将三人从左岸运到右岸，然后再有一个人将船送回来。这样，船一个来回可以运过河2人，而船仍然在左岸。而最后剩下的三个人，则可以一次将他们全部从左岸运到右岸。所以，在不考虑限制条件的情况下，也至少需要摆渡[(M+N-3)/2]*2+1次。其中分子上的”－3”表示剩下三个留待最后一次运过去。除以”2”是因为一个来回可以运过去2人，需要[(M+N-3)/2]个来回，而”来回”数不能是小数，需要向上取整，这个用符号[ ]表示。而乘以”2”是因为一个来回相当于两次摆渡，所以要乘以2。而最后的”＋1”，则表示将剩下的3个运过去，需要一次摆渡。 化简得：需要 M+N-2次单向摆渡 （2）再考虑船在右岸的情况。同样不考虑限制条件。船在右岸，需要一个人将船运到左岸。因此对于状态(M，N，0)来说，其所需要的最少摆渡数，相当于船在左岸时状态(M+1，N，1)或(M，N+1，1)所需要的最少摆渡数，再加上第一次将船从右岸送到左岸的一次摆渡数。因此所需要的最少摆渡数为：(M+N+1)-2+1。其中(M+N+1)的”＋1”表示送船回到左岸的那个人，而最后边的”＋1”，表示送船到左岸时的一次摆渡。 化简有：(M+N+1)-2+1=M+N。 综合船在左岸和船在右岸两种情况下，所需要的最少摆渡次数用一个式子表示为：$M+N-2B$ ，其中B＝1表示船在左岸，B＝0表示船在右岸。该摆渡次数是在不考虑限制条件下，推出的最少所需要的摆渡次数。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2019%2F10%2F01%2F%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[鸣谢：https://www.jianshu.com/p/0eaea4cc5619https://blog.csdn.net/tanrui519521/article/details/80980135https://zhuanlan.zhihu.com/p/24367771 删除：https://www.cnblogs.com/tongy0/p/5460623.html 红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。 性能优于AVL树，C++中的map，以及Java中的TreeMap，TreeSet， Java8中的HashMap的实现也采用了红黑树。 5条基本特征： （1）每个结点要么是红的要么是黑的。（2）根结点是黑的。（3）每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。（4）如果一个结点是红的，那么它的两个儿子都是黑的。（5）对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。 红黑树的5条特性确保了从根到叶子的最长的可能路径不多于最短的可能路径的两倍长，使得整棵树大致上是平衡的 树的插入：（警惕红） 新插入的节点总是设为红色的，所以如果父节点为黑色，就不需要修复，因为没有任何性质被改变，所以只有在父节点为红色节点时需要做修复操作。 可以肯定调节的时候该点一定有grandparent，因为根节点为黑，连续两个红才需要调整。 情况1：cur为红，parent为红，pParent为黑，uncle存在且为红则将parent，uncle改为黑，pParent改为红，然后把pParent当成cur，继续向上调整。 对策 :把父节点和叔叔节点变黑，爷爷节点涂红，然后把当前节点指针给到爷爷，让爷爷节点那层继续循环，接受红黑树特性检测。 情况2：cur为红，parent为红，pParent为黑，uncle不存在/u为黑 对策：当前节点的父节点作为新的当前节点，以新当前指点为支点左旋 parent为pParent的左孩子，cur为parent的左孩子，则进行右单旋转。 情况3：当前节点的父节点是红色，叔叔节点是黑色/不存在，且当前节点是其父节点的右儿子，祖父节点的左儿子是父节点 对策： 父节点变黑，祖父变红，以祖父节点为支点右旋 1为当前点，祖父节点为下一轮遍历的当前节点。 4为当前点，取初始父节点3为下一轮遍历的当前节点。然后交换一下3和4，然后再重组 3为当前点，取父亲为下一轮遍历的当前节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;vector&gt;using namespace std;#define N 1000#define red true#define black falseclass Node&#123; public: static int length; bool br; // true red false black int num; Node*l,*r,*f; Node()&#123; num=-1; r=f=l=NULL; &#125; &#125;;int Node::length=0;void left_turn(Node*&amp;root)&#123; Node*p=root-&gt;f; Node*pP=root-&gt;f-&gt;f; if(p-&gt;l)&#123; p-&gt;l-&gt;f=pP; &#125; p-&gt;f=pP-&gt;f; pP-&gt;r=p-&gt;l; p-&gt;l=pP; if(pP-&gt;f==NULL)&#123; &#125; else if(pP-&gt;f-&gt;num&gt;pP-&gt;num)&#123; pP-&gt;f-&gt;l=p; &#125; else&#123; pP-&gt;f-&gt;r=p; &#125; pP-&gt;f=p;&#125;void right_turn(Node*&amp;root)&#123; Node*p=root-&gt;f; Node*pP=root-&gt;f-&gt;f; if(p-&gt;r)&#123; p-&gt;r-&gt;f=pP; &#125; p-&gt;f=pP-&gt;f; pP-&gt;l=p-&gt;r; p-&gt;r=pP; if(pP-&gt;f==NULL)&#123; &#125; else if(pP-&gt;f-&gt;num&gt;pP-&gt;num)&#123; pP-&gt;f-&gt;l=p; &#125; else&#123; pP-&gt;f-&gt;r=p; &#125; pP-&gt;f=p;&#125;void balance(Node*&amp;root)&#123; // 如果是top点，没有father/grandfather需要单独讨论，因为可能是红点做top点 if(root-&gt;f==NULL)&#123; root-&gt;br=black; return; &#125; else if(root-&gt;br==black)&#123; return; &#125; if(root-&gt;f-&gt;br==red)&#123; // Need to deal with this situation. // first decide you are in which side(l/r). there will be two choice and four cases. if(root-&gt;f-&gt;f-&gt;l&amp;&amp;root-&gt;f-&gt;f-&gt;r&amp;&amp;root-&gt;f-&gt;f-&gt;l-&gt;br==red&amp;&amp;root-&gt;f-&gt;f-&gt;r-&gt;br==red)&#123; // balance1 , p=red , uncle=red root-&gt;f-&gt;f-&gt;br=red; root-&gt;f-&gt;f-&gt;l-&gt;br=black; root-&gt;f-&gt;f-&gt;r-&gt;br=black; balance(root-&gt;f-&gt;f); &#125; else&#123; // balance2, p(left)=red , uncle=black/NULL if(root-&gt;f-&gt;f-&gt;r==NULL||root-&gt;f-&gt;f-&gt;r-&gt;br==black)&#123; // right turn Node*pP=root-&gt;f-&gt;f; Node*p=root-&gt;f; if(root-&gt;f-&gt;num&gt;root-&gt;num)&#123; p-&gt;br=black; pP-&gt;br=red; right_turn(root); balance(root-&gt;f); &#125; else&#123; root-&gt;br=black; pP-&gt;br=red; // adjust if(root-&gt;l)&#123; root-&gt;l-&gt;f=root-&gt;f; &#125; p-&gt;r=root-&gt;l; pP-&gt;l=root; root-&gt;f=pP; root-&gt;l=p; p-&gt;f=root; right_turn(root-&gt;l); balance(root); &#125; &#125; // balance3 , p(right)=red , uncle(left)=black/NULL else&#123; // warm up Node*pP=root-&gt;f-&gt;f; Node*p=root-&gt;f; //left turn if(root-&gt;f-&gt;num&gt;root-&gt;num)&#123; root-&gt;br=black; pP-&gt;br=red; // adjust pP-&gt;r=root; p-&gt;f=root; root-&gt;f=pP; Node*t=root; // 为了防止root被误置为NULL,出此下策保留该root指针 p-&gt;l=root-&gt;r; // bug p-&gt;l(指向root的左指针)=root-&gt;r 变成了 root=root-&gt;r root=t; root-&gt;r=p; left_turn(root-&gt;r); balance(root); &#125; else&#123; p-&gt;br=black; pP-&gt;br=red; left_turn(root); balance(root-&gt;f); &#125; &#125; &#125; &#125; else&#123; return; &#125;&#125;Node* leave=NULL;Node* insert(Node*&amp;root,int num)&#123; if(root==NULL)&#123; Node *node=new Node(); node-&gt;num=num; node-&gt;br=red; if(node-&gt;length==0)&#123; // root必须为black node-&gt;length=1; node-&gt;br=black; &#125; root=node; leave=root; return node; &#125; else if(root-&gt;num&gt;num)&#123; root-&gt;l=insert(root-&gt;l,num); root-&gt;l-&gt;f=root; &#125; else&#123; root-&gt;r=insert(root-&gt;r,num); root-&gt;r-&gt;f=root; &#125; return root;&#125;// 打印看看结构void print(Node*root)&#123; if(root==NULL)&#123; return; &#125; cout&lt;&lt;root-&gt;num&lt;&lt;&quot; color: &quot;&lt;&lt;(root-&gt;br==black?&quot;black&quot;:&quot;red&quot;)&lt;&lt;endl; print(root-&gt;l); print(root-&gt;r);&#125;int main()&#123; int i,j,input,k; int p,e; Node*root=NULL; freopen(&quot;inputs.txt&quot;,&quot;r+&quot;,stdin); cin&gt;&gt;p; for(i=0;i&lt;p;i++)&#123; cin&gt;&gt;e; insert(root,e); balance(leave); root-&gt;length++; &#125; cout&lt;&lt;&quot;preorder :\n&quot;; print(root);&#125;/*75 7 1 4 6 3 25 color: black3 color: red1 color: black2 color: red4 color: black7 color: black6 color: red6 7 0 4 5 2 16 color: black4 color: red1 color: black0 color: red2 color: red5 color: black7 color: black*/ 树的删除：（警惕黑） 在红黑树中，删除一个节点往大的说，只有以下四种情况。 情况一：删除的节点的左、右子树都非空； 情况二：删除的节点的左子树为空树，右子树非空； 情况三：删除的节点的右子树为空树，左子树非空； 情况四：删除的节点的左、右子树都为空树； 其中情况一，可以按与其他二叉搜索树的删除方式一样处理，最终可以转换到后面的三种情况。具体为：找到(Old)D节点的直接后继节点(暂且称为X节点)，然后将X的值转移到D节点，最后将X节点作为真正要被删除掉的节点(即：(Real)D节点)。这样删除操作后，可以保证该树仍然为一棵二叉搜索树。但这样删除(Real)D节点后，可能会破坏红黑树的性质。所以需要额外做一些调整处理，这便是下面将要详细讨论的内容。 说明：下文中所提到的D，除非有特别说明，否则都将指的是(Real)D（一般可以认为该RealD节点的左子树为空，OldD不一定），最终要删除的节点一般是OldD的右节点或者右节点的最前面的一个左节点，当然也可能无右节点只能删自己。 删除的类别可以分为几种： （1）首先 ，从当前点D和DR之间的颜色顺序看。 &lt; 1 &gt; 红-&gt;黑/NULL ，P肯定为黑 ， 直接删掉红，用黑（NULL）替换。 &lt; 2 &gt; 黑-&gt;红 ，直接拿红替换黑，然后红变黑。 &lt; 3 &gt; 黑-&gt;黑 / NULL ， 情况变得复杂。 （2）然后 ，根据uncle的颜色再分一次情况讨论： &lt; 1 &gt; 如果uncle是红，那就很容易了。因为P不可能是红只能是黑，只有一种情况。 &lt; 2 &gt; uncle为黑时，特别复杂。 1.SL=红，uncle=黑，P=黑/红，SR=黑/红 将S右旋转时，接着将SL改为P的颜色，P的颜色改为黑色(用这个黑色来填补DR分支的黑节点数)，将P左旋转。 2.SR=红，P=黑/红，SL=黑/红 3.S=黑，P=红，SL=SR=黑（处理简单，只要变色） 4.SR=SL=黑，P=黑（处理简单，只要变色）]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kd树]]></title>
    <url>%2F2019%2F10%2F01%2Fd%2F</url>
    <content type="text"><![CDATA[kd树：计算时采用线性扫描的方式O(n^2)，效率奇低。采用平衡二叉树的方法存储各个点，用中位数做分割，划分左右区间，并进行以x-y轴为中心进行交替选择。 算法复杂度： 构建：O(log2n)插入：O(log n)删除：O(log n)查询：平均情况下 O(log n) ，最好情况 O(1)，最坏情况O(n) 构建kd树： （1）按y排序，抽取其中的中位数（向上取整）对应的点，axis代表的维自增。每个node保留一个指针指向父节点。 怎么确定split域的首先该取的值（先划分x轴还是y轴）？ 分别计算x，y方向上数据的方差得知x方向上的方差最大 搜寻确定查询点最小范围的点： （1）先以y分割判断点A&gt;Sy，向左子树查。（2）再以x分割判断B&lt;Sy，向右子树搜索。 while查找二维空间里的最近点。 如果点非空而且栈非空（在根节点退到root-&gt;f即空节点而且栈为空（叶节点情况下一般栈非空））退出。（1）如果 minr &lt; r(当前点，搜索点)，则无需查找另外一侧的子节点。r=r-&gt;f（2）如果minr &gt; r(当前点，搜索点)，则去另一侧的子节点找找看。r=r-&gt;l/r（看你搜索点在线的哪一侧（根据x/y相对大小），取反方向即可），同时，stack记录r。（3）当r==NULL，触底回退到stack为空（保留stack[0]），然后r=r-&gt;f（会不会重新陷回r-&gt;l/r ？不会左边的minr可能值都遍历了，所以会使r指向另一侧，等栈pop回到原点时又毫不留情r=r-&gt;f） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;map&gt;using namespace std;int splits=0;// 维数int now_axis=0;// 当前所在维数class kd_tree&#123; public: vector&lt;float&gt;point; // (x,y,z...) float range; // x&lt;range and x&gt;range int split; // x,y,z....轴标记 kd_tree*l; kd_tree*r; kd_tree*f; kd_tree()&#123; l=NULL; r=NULL; f=NULL; range=0; split=0; &#125;&#125;;kd_tree* insert(kd_tree*root,vector&lt;float&gt;v,int split)&#123; if(root==NULL)&#123; root=new kd_tree(); root-&gt;point.assign(v.begin(),v.end()); root-&gt;split=split; root-&gt;range=v[split]; root-&gt;point.assign(v.begin(),v.end()); &#125; else&#123; if(v[root-&gt;split]&gt;root-&gt;range)&#123; root-&gt;r=insert(root-&gt;r,v,split); root-&gt;r-&gt;f=root; &#125; else if(v[root-&gt;split]&lt;root-&gt;range)&#123; root-&gt;l=insert(root-&gt;l,v,split); root-&gt;l-&gt;f=root; &#125; &#125; return root;&#125;// 排序用bool cmp(vector&lt;float&gt;a,vector&lt;float&gt;b)&#123; return a[now_axis]&lt;b[now_axis];&#125;// 初始化必须集齐所有数据void init(kd_tree*&amp;root,vector&lt;vector&lt;float&gt;&gt;v,int left,int right,int split)&#123; if(left&gt;right)&#123; return; &#125; now_axis=split%splits; sort(v.begin()+left,v.begin()+right+1,cmp); int middle=(left+right+1)/2; // +1是向上取整，不加是向下取整 root=insert(root,v[middle],now_axis); init(root,v,left,middle-1,split+1); init(root,v,middle+1,right,split+1); return;&#125;int choose_split(vector&lt;vector&lt;float&gt;&gt;v)&#123; int i,j; vector&lt;float&gt;ave(splits); for(i=0;i&lt;splits;i++)&#123; float sum=0; for(j=0;j&lt;v.size();j++)&#123; sum+=v[j][i]; &#125; ave[i]=sum/float(v.size()); &#125; int ans=0; float maxd=0; for(i=0;i&lt;splits;i++)&#123; float sumd=0; for(j=0;j&lt;v.size();j++)&#123; sumd+=(v[j][i]-ave[i])*(v[j][i]-ave[i]); &#125; if(sumd&gt;maxd)&#123; ans=i; maxd=sumd; &#125; &#125; return ans;&#125;kd_tree* find_range(kd_tree*root,vector&lt;float&gt;&amp;v)&#123; if(root-&gt;point[root-&gt;split]&gt;v[root-&gt;split])&#123; if(root-&gt;l==NULL)&#123; return root; &#125; else&#123; find_range(root-&gt;l,v); &#125; &#125; else if(root-&gt;point[root-&gt;split]&lt;v[root-&gt;split])&#123; if(root-&gt;r==NULL)&#123; return root; &#125; else&#123; find_range(root-&gt;r,v); &#125; &#125; else&#123; return root; &#125;&#125;void preorder(kd_tree*root)&#123; if(root==NULL)&#123; return; &#125; cout&lt;&lt;root-&gt;point[0]&lt;&lt;&quot;,&quot;&lt;&lt;root-&gt;point[1]&lt;&lt;endl; cout&lt;&lt;(root-&gt;split==0?&quot;x&quot;:&quot;y&quot;)&lt;&lt;&quot;:&quot;&lt;&lt;root-&gt;range&lt;&lt;endl; preorder(root-&gt;l); preorder(root-&gt;r);&#125;// 最小半径的平方float minr=0x7fffffff;kd_tree* find_nearest_node(kd_tree*root,vector&lt;float&gt;&amp;v)&#123; if(root==NULL)&#123; return NULL; &#125; kd_tree*ans=root; vector&lt;kd_tree*&gt;list; while(!(root==NULL)||!list.empty())&#123; // if(root)&#123; // 打印路径 // cout&lt;&lt;root-&gt;point[0]&lt;&lt;&quot; &quot;&lt;&lt;root-&gt;point[1]&lt;&lt;endl; // &#125; if(root==NULL)&#123; root=list[0]; while(!list.empty())&#123; list.pop_back(); &#125; root=root-&gt;f; &#125; else&#123; int i=0; float r_now=0; // calc the distance^2 for(i=0;i&lt;splits;i++)&#123; r_now+=(root-&gt;point[i]-v[i])*(root-&gt;point[i]-v[i]); &#125; if(r_now&lt;minr)&#123; // current point is much more near minr=r_now; ans=root; &#125; if((root-&gt;point[root-&gt;split]-v[root-&gt;split])*(root-&gt;point[root-&gt;split]-v[root-&gt;split])&gt;=minr)&#123; // if the cirle which based on the radius between current point and the point to be searched // doesn&apos;t intersect with the straight line(x=...,y=...), then search the father side; root=root-&gt;f; if(!list.empty())&#123; list.pop_back(); &#125; &#125; else&#123; list.push_back(root); // or turn to the other side of if(v[root-&gt;split]&lt;root-&gt;point[root-&gt;split])&#123; root=root-&gt;r; &#125; else&#123; root=root-&gt;l; &#125; &#125; &#125; &#125; return ans;&#125;int main()&#123; freopen(&quot;inputs.txt&quot;,&quot;r+&quot;,stdin); int length; int i,j,x; vector&lt;vector&lt;float&gt;&gt;v; kd_tree* root=NULL; cin&gt;&gt;length; cin&gt;&gt;splits; for(i=0;i&lt;length;i++)&#123; vector&lt;float&gt;vv; for(j=0;j&lt;splits;j++)&#123; cin&gt;&gt;x; vv.push_back(x); &#125; v.push_back(vv); &#125; int left=0,right=v.size()-1,split; split=choose_split(v); // choose the largest D(..) to define x/y/z as the start axis. init(root,v,left,right,split); // init the b-tree. if(root==NULL)&#123; cout&lt;&lt;&quot;failed&quot;&lt;&lt;endl; &#125; vector&lt;float&gt;vvv=&#123;2,4.5&#125;; // point to be search. kd_tree*r=find_range(root,vvv); // return the range define node. r=find_nearest_node(r,vvv); // return the answer node cout&lt;&lt;(split==0?&quot;x&quot;:&quot;y&quot;)&lt;&lt;&quot; as the firat axis.&quot;&lt;&lt;endl; cout&lt;&lt;&quot;\nr^2: &quot;&lt;&lt;minr&lt;&lt;endl; cout&lt;&lt;&quot;\nanswer node: (&quot;&lt;&lt;r-&gt;point[0]&lt;&lt;&quot;,&quot;&lt;&lt;r-&gt;point[1]&lt;&lt;&quot;)&quot;&lt;&lt;endl; return 0;&#125;/*622 34 75 47 28 19 6(5,4)*/]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[感知机]]></title>
    <url>%2F2019%2F08%2F15%2F%E6%84%9F%E7%9F%A5%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[感知机是二分类的线性模型，其输入是实例的特征向量，输出的是事例的类别，分别是+1和-1，属于判别模型。假设训练数据集是线性可分的，感知机学习的目标是求得一个能够将训练数据集正实例点和负实例点完全正确分开的分离超平面。如果是非线性可分的数据，则最后无法获得超平面 点到线的距离公式： $d=\frac{Ax_0+By_0+C}{\sqrt{A^2+B^2}}$ 假设有一超平面，h=w*x+b，其中w=（w0，w1…wm），x=（x0，x1…xm），样本x’到超平面的距离为： $d=\frac{w*x’+b}{||w||}$ 输出的模型如下： $f(x)=sign(w*x+b)$ $sign(x)=\begin{cases} 1 \quad\quad\quad x&gt;0 -1 \quad\quad\quad x\leq0\end{cases}$ 如果 $ \frac{w\star x’+b}{||w||}&gt;0 $，则y=1。如果&lt;0，则y=-1。这样分类正确的话 $y*\frac{w\star x’+b}{||w||}&gt;0$ 恒成立（||w||是L2范数） 损失函数：$L(w,b)=-\frac{1}{||w||}\sum_{x_i \in M}y_i(w*x_i+b)$（M集合是误分类点的集合） 当然因为||$w$||&gt;0所以我们可以去掉它 $L(w,b)=-\sum_{x_i \in M}y_i(w*x_i+b)$ 感知机分类的最终目的是让最终值=0，所以少除也无所谓，还能降低计算量。(所以有个前提：能收敛到0) 随机梯度下降算法用普通的基于所有样本的梯度和的均值的批量梯度下降法（BGD）是行不通的，原因在于我们的损失函数里面有限定，只有误分类的M集合里面的样本才能参与损失函数的优化。所以我们不能用最普通的批量梯度下降,只能采用随机梯度下降（SGD） $\nabla_wL(w,b)=-\sum_{x_i \in M}y_i*x_i$ $\nabla_bL(w,b)=-\sum_{x_i \in M}y_i$ $w \gets w+\etay_ix_i$ $b \gets b+\eta*y_i$ xi实际上是(x,y)，yi实际上是{-1，1}，$\eta$是步长。 计算过程： 获取{-1，1}对应的点，初始化w矩阵和b变量的值。 正确分类的不用管，不正确分类的利用梯度对w和b的值进行更新。 循环带入所有的点，直到满足要求。 例：点x1=（3，3），w0=0，b0=0，y1=1，步长为1 1. y1*（w0*x1+b0）=0，分类错误。 2. w1=w0+y1*x1=(3，3)^T，b1=b0+y1=1 3. 得到线性模型 f（x）=sign（3x+3y+1）(只输出在线的哪一侧) 对偶形式算法：对偶形式的目的是降低运算量，但是并不是在任何情况下都能降低运算量，而是在特征空间的维度很高时才起到作用。 原： $w \gets w+\etay_ix_i$ $b \gets b+\eta*y_i$ 现： 初始值为（0，0）的w和b经过了n次修改后：（$a_i=n_i\eta$） $w=\sum_{i=1}^na_iy_ix_i$ $b=\sum_{i=1}^na_iy_i$ $sign（wx+b）$，将$w=\sum_{i=1}^na_iy_ix_i$带入得$f(x)=\sum_{i=1}^na_iy_ix_ixj+b$ 第n-1次的参数$a_i$在第2(n-1)轮要再加$\eta$，所以参数$a_i$越大，说明该点位于分割线附近，在更新的时候容易受影响难以正确分类。$a_i$默认初始为0 $a_i \gets a_i+\eta$ $b \gets b+\eta y_i$ 加速的设计：gram矩阵，$G=[x_ix_j]_{NN}$ 很可惜，因为不能解决异或问题躺尸了很多年。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[new和malloc的区别]]></title>
    <url>%2F2019%2F08%2F14%2Fnew%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[new与malloc的区别?（1）申请的内存所在位置:new操作符从自由存储区上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。 那么自由存储区是否能够是堆，这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。 在C++中，内存区分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区，但是new其实是对malloc的封装，所以只是逻辑上有所区别…. （2）返回类型安全性：new操作符内存分配成功时，返回的是对象类型的指针，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void ，需要通过强制类型转换将void指针转换成我们需要的类型。 （3）是否调用构造函数/析构函数：使用new操作符来分配对象内存时会经历三个步骤：第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。第三部：对象构造完成后，返回一个指向该对象的指针。 使用delete操作符来释放对象内存时会经历两个步骤：第一步：调用对象的析构函数。第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。]]></content>
      <categories>
        <category>C++</category>
        <category>操作系统底层</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>操作系统底层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存垃圾管理（智能指针）]]></title>
    <url>%2F2019%2F08%2F14%2F%E5%9E%83%E5%9C%BE%E7%AE%A1%E7%90%86%EF%BC%88%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[智能指针：https://blog.csdn.net/u012501459/article/details/48229399 C++11中引入了智能指针的概念。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，使用智能指针能更好的管理堆内存。 构造函数中创建类的新对象时，初始化引用计数为1； 拷贝构造函数复制指针，并使相应的引用计数增加1； 赋值操作减少左操作数所值对象的引用计数，增加右操作数所指对象的引用计数； 析构函数使引用计数减少1，并且当引用计数为0时，释放指针说指向的对象； Ref_ptr类：1234567891011121314//使用int*指针初始化ptr，注意必须要放在初始化列表中Ref_ptr(int * i):ptr(new Referenced(i))&#123;&#125;//拷贝构造函数，又有一个变量指向了这块内存Ref_ptr(const Ref_ptr &amp; rhs)&#123; ptr=rhs.ptr;//将右操作数的引用计数对象赋值给左操作数 ptr-&gt;ref();//将它们的应用计数加1&#125;Ref_ptr r1=new int(4); //调用构造函数Ref_ptr r2=r1; //调用拷贝构造函数 123456789101112131415161718192021222324//赋值操作符，右操作数的引用计数要减1，左操作数的引用计数要加1Ref_ptr &amp; operator=(const Ref_ptr &amp; rhs)&#123; if(&amp;rhs==this) return *this; if(ptr-&gt;unref()==0)//赋值操作符，首先将当前类的引用计数减1，因为现在指向它的指针少了一个。 &#123; cout&lt;&lt;&quot;delete Ref_ptr&quot;&lt;&lt;endl; delete ptr; &#125; ptr=rhs.ptr; //将右操作数的引用计数赋值给当前对象 ptr-&gt;ref(); //引用计数加1 return *this;&#125;//析构函数，引用计数要减1，如果减为0，删除这块内存~Ref_ptr()&#123; if(ptr-&gt;unref()==0) &#123; cout&lt;&lt;&quot;delete Ref_ptr&quot;&lt;&lt;endl; delete ptr; &#125;&#125; Referenced类：12345678910111213141516171819202122232425//初始化这个类，引用计数设为1，并且将p指向传入的地址Referenced(int * pi)&#123; refCount=1; p=pi;&#125;//引用计数加1int ref()&#123; return ++refCount;&#125; //引用计数减1int unref()&#123; return --refCount;&#125;//析构函数，释放掉内存~Referenced()&#123; cout&lt;&lt;&quot;delete referenced&quot;&lt;&lt;endl; delete p;&#125; 好处： 智能指针能够帮助我们处理资源泄露问题； 它也能够帮我们处理空悬指针的问题； 它还能够帮我们处理比较隐晦的由异常造成的资源泄露。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL里的四种智能指针auto_ptr,scoped_ptr,shared_ptr,weak_ptr]]></title>
    <url>%2F2019%2F08%2F14%2FL%E9%87%8C%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-auto-ptr%E3%80%81scoped-ptr%E3%80%81shared-ptr%E3%80%81weak-ptr%2F</url>
    <content type="text"><![CDATA[基于安全考虑：123auto_ptr&lt; string&gt; ps (new string (&quot;I reigned lonely as a cloud.”）;auto_ptr&lt;string&gt; vocation; vocaticn = ps; 因为程序将试图删除同一个对象两次，要避免这种问题，方法有多种： （1）定义赋值运算符，使之执行深复制。这样两个指针将指向不同的对象，其中的一个对象是另一个对象的副本，缺点是浪费空间，所以智能指针都未采用此方案。 （2）建立所有权概念。对于特定的对象，只能有一个智能指针可拥有，这样只有拥有对象的智能指针的析构函数会删除该对象。然后让赋值操作转让所有权。这就是用于auto_ptr和unique_ptr 的策略，但unique_ptr的策略更严格。 （3）创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数。例如，赋值时，计数将加1，而指针过期时，计数将减1,。当减为0时才调用delete。这是shared_ptr采用的策略。 1. unique_ptr：unique_ptr由C++11引入，旨在替代不安全的auto_ptr。unique_ptr不共享它的所管理的对象。它无法复制到其他unique_ptr，无法通过值传递到函数，也无法用于需要副本的任何标准模板库 （STL）算法。只能移动 unique_ptr，即对资源管理权限可以实现转移。 123456789101112//智能指针的创建 unique_ptr&lt;int&gt; u_i; //创建空智能指针u_i.reset(new int(3)); //&quot;绑定”动态对象 unique_ptr&lt;int&gt; u_i2(new int(4));//创建时指定动态对象unique_ptr&lt;T,D&gt; u(d); //创建空unique_ptr,执行类型为T的对象，用类型为D的对象d来替代默认的删除器delete//所有权的变化 int *p_i = u_i2.release(); //释放所有权 unique_ptr&lt;string&gt; u_s(new string(&quot;abc&quot;)); unique_ptr&lt;string&gt; u_s2 = std::move(u_s); //所有权转移(通过移动语义)，u_s所有权转移后，变成“空指针” u_s2.reset(u_s.release());//所有权转移u_s2=nullptr;//显式销毁所指对象，同时智能指针变为空指针。与u_s2.reset()等价 2.auto_ptr：为什么不用它而用unique_ptr使用unique_ptr时编译出错，与auto_ptr一样，unique_ptr也采用所有权模型，但在使用unique_ptr时，程序不会等到运行阶段崩溃，而在编译期因下述代码行出现错误。一句话总结就是：避免因潜在的内存问题导致程序崩溃。123456789101112131415161718int main()&#123; auto_ptr&lt;string&gt; films[5] =&#123; auto_ptr&lt;string&gt; (new string(&quot;Fowl Balls&quot;)), auto_ptr&lt;string&gt; (new string(&quot;Duck Walks&quot;)), auto_ptr&lt;string&gt; (new string(&quot;Chicken Runs&quot;)), auto_ptr&lt;string&gt; (new string(&quot;Turkey Errors&quot;)) &#125;; auto_ptr&lt;string&gt; pwin; pwin = films[2]; // films[2] loses ownership. 将所有权从films[2]转让给pwin，此时films[2]不再引用该字符串从而变成空指针 for(int i = 0; i &lt; 4; ++i) &#123; cout &lt;&lt; *films[i] &lt;&lt; endl; &#125; return 0;&#125; 从上面可见，unique_ptr比auto_ptr更加安全，因为auto_ptr有拷贝语义，拷贝后原象变得无效，再次访问原对象时会导致程序崩溃；unique_ptr则禁止了拷贝语义，但提供了移动语义，即可以使用std::move()进行控制权限的转移12345678unique_ptr&lt;string&gt; upt(new string(&quot;lvlv&quot;));unique_ptr&lt;string&gt; upt1(upt); //编译出错，已禁止拷贝unique_ptr&lt;string&gt; upt1=upt; //编译出错，已禁止拷贝unique_ptr&lt;string&gt; upt1=std::move(upt); //控制权限转移，正确的写法auto_ptr&lt;string&gt; apt(new string(&quot;lvlv&quot;));auto_ptr&lt;string&gt; apt1(apt); //编译通过auto_ptr&lt;string&gt; apt1=apt; //编译通过 使用shared_ptr时运行正常，因为shared_ptr采用引用计数，pwin和films[2]都指向同一块内存，在释放空间时因为事先要判断引用计数值的大小因此不会出现多次删除一个对象的错误。 3. shared_ptr参看内存垃圾管理（智能指针） 4. weak_ptr被设计为与shared_ptr共同工作，可以从一个shared_ptr或者另一个weak_ptr对象构造而来。 循环引用： 一般来讲，解除这种循环引用有下面三种可行的方法：（1）当只剩下最后一个引用的时候需要手动打破循环引用释放对象。（2）当parent的生存期超过children的生存期的时候，children改为使用一个普通指针指向parent。（3）使用弱引用的智能指针打破这种循环引用。虽然这三种方法都可行，但方法1和方法2都需要程序员手动控制，麻烦且容易出错。这里主要介绍一下第三种方法，使用弱引用的智能指针std:weak_ptr来打破循环引用。]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[__cdecl,__stdcall,__fastcall,__pascal,__thiscall 的区别]]></title>
    <url>%2F2019%2F08%2F14%2Fecl-stdcall-fastcall-pascal-thiscall-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[关于函数的调用规则（调用约定），大多数时候是不需要了解的，但是如果需要跨语言的编程，比如VC写的dll要delphi调用，则需要了解。 1.__cdecl __cdecl 是 C Declaration 的缩写，表示 C 语言默认的函数调用方法：所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。 2.__stdcall __stdcall 是 Standard Call 的缩写，是 C++ 的标准调用方式：所有参数从右到左依次入栈，如果是调用类成员的话，最后一个入栈的是 this 指针。这些堆栈中的参数由被调用的函数在返回后清除，使用的指令是 retnX，X 表示参数占用的字节数，CPU 在 ret 之后自动弹出 X 个字节的堆栈空间，称为自动清栈。函数在编译的时候就必须确定参数个数，并且调用者必须严格的控制参数的生成，不能多，不能少，否则返回后会出错。 3.__fastcall fastcall 是编译器指定的快速调用方式。由于大多数的函数参数个数很少，使用堆栈传递比较费时。因此 fastcall 通常规定将前两个（或若干个）参数由寄存器传递，其余参数还是通过堆栈传递。不同编译器编译的程序规定的寄存器不同，返回方式和 __stdcall 相当。 4.__pascal pascal 是 Pascal 语言（Delphi）的函数调用方式，也可以在 C/C++ 中使用，参数压栈顺序与前两者相反。返回时的清栈方式与 stdcall 相同。 5.__thiscall thiscall 是为了解决类成员调用中 this 指针传递而规定的。thiscall 要求把 this 指针放在特定寄存器中，该寄存器由编译器决定。VC 使用 ecx，Borland 的 C++ 编译器使用 eax。返回方式和 __stdcall 相当。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存对齐]]></title>
    <url>%2F2019%2F08%2F13%2F%E5%AD%98%E5%AF%B9%E9%BD%90%2F</url>
    <content type="text"><![CDATA[12345typedef struct &#123; int a; double b; short c;&#125;A; 12345typedef struct &#123; int a; short b; double c;&#125;B; sizeof(A)=24而sizeof(B)=16 A的内存分布：(每一个元素都存在最大元素大小的空间内) B的内存分布：]]></content>
      <categories>
        <category>C++</category>
        <category>操作系统底层</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>操作系统底层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大小端存储]]></title>
    <url>%2F2019%2F08%2F13%2F%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[大端模式，是指数据的高字节保存在内存的低地址中。 4个两位16进制数=8*4=32位=4B=1int 编程判断大小端的两种方法： union 判断法 在union中所有的数据成员共用一个空间，同一时间只能储存其中一个数据成员，所有的数据成员具有相同的起始地址。即上述的union虽然定义了两个成员，但其实这个union只占用了4个字节(32位机器中)，往a成员赋值，然后读取b就相读取a成员的低位第一个字节的值。如果机器使用大端模式，则u.a=1那a的最高字节值为1；1234567891011typedef union &#123; int i; char c;&#125;my_union; int checkSystem1(void)&#123; my_union u; u.i = 1; return (u.i == u.c);&#125; 直接判断法 123456int checkSystem2(void)&#123; int i = 0x12345678; char *c = (char*)&amp;i; return ((c[0] == 0x78) &amp;&amp; (c[1] == 0x56) &amp;&amp; (c[2] == 0x34) &amp;&amp; (c[3] == 0x12));&#125;]]></content>
      <categories>
        <category>C++</category>
        <category>操作系统底层</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>操作系统底层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针的形参]]></title>
    <url>%2F2019%2F08%2F13%2F%E6%8C%87%E9%92%88%E7%9A%84%E5%BD%A2%E5%8F%82%2F</url>
    <content type="text"><![CDATA[函数中传递的是p指针的形参（只能修改arr[1]的值，无法修改*p指向的位置） *p形参的情况： 一开始: graph LR classDef className fill:white,stroke:#333,stroke-width:1px; id3[*p 形参]-->id1[7] subgraph arr数组 id[10]-->id1[7] id1[7]-->id2[5] end subgraph *p id3[*p 形参] end class id,id1,id2,id3 className; 最后: graph LR classDef className fill:white,stroke:#333,stroke-width:1px; id4[*p]-->id1[3] id3[*p 形参]-->id[10] subgraph *p 形参 id3[*p 形参] end subgraph *p id4[*p] end subgraph arr数组 id[10]-->id1[3] id1[3]-->id2[5] end class id,id1,id2,id3,id4 className; 注意：*p--=3实际上是*p=3，然后(p--) 123456789101112#include&lt;iostream&gt;using namespace std;int func(int *p)&#123; return (*p--=3)-1;&#125;int main()&#123; int arr[]=&#123;10,7,5&#125;; int *p=arr+1; printf(&quot;%d&quot;,func(p)+*p); // 答案为5&#125; *&amp;p引用的情况： 一开始: graph LR classDef className fill:white,stroke:#333,stroke-width:1px; id3[*&p]-->id1[7] subgraph arr数组 id[10]-->id1[7] id1[7]-->id2[5] end subgraph *&p id3[*&p] end class id,id1,id2,id3 className; 最后: graph LR classDef className fill:white,stroke:#333,stroke-width:1px; id4[*p]-->id[10] id3[*&p]-->id[10] subgraph *&p id3[*&p] end subgraph *p id4[*p] end subgraph arr数组 id[10]-->id1[3] id1[3]-->id2[5] end class id,id1,id2,id3,id4 className; 123456789101112#include&lt;iostream&gt;using namespace std;int func(int *&amp;p)&#123; return (*p--=3)-1;&#125;int main()&#123; int arr[]=&#123;10,7,5&#125;; int *p=arr+1; printf(&quot;%d&quot;,func(p)+*p); // 答案为12&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[#ifndef/#define/#endif]]></title>
    <url>%2F2019%2F08%2F13%2Fifndef-define-endif%2F</url>
    <content type="text"><![CDATA[在c语言中，对同一个变量或者函数进行多次声明是不会报错的。所以如果h文件里只是进行了声明工作，即使不使用# ifndef宏定义，多个c文件包含同一个h文件也不会报错。 但是在c++语言中，#ifdef的作用域只是在单个文件中。所以如果h文件里定义了全局变量，即使采用#ifdef宏定义，多个c文件包含同一个h文件还是会出现全局变量重定义的错误。 使用#ifndef可以避免下面这种错误：如果在h文件中定义了全局变量，一个c文件包含同一个h文件多次，如果不加#ifndef宏定义，会出现变量重复定义的错误；如果加了#ifndef，则不会出现这种错误。 其实“被重复引用”是指一个头文件在同一个cpp文件中被include了多次，这种错误常常是由于include嵌套造成的。比如：存在a.h文件#include “c.h”而此时b.cpp文件导入了#include “a.h” 和#include “c.h”此时就会造成c.h重复引用。 12345#ifndef x //先测试x是否被宏定义过#define x 程序段1blabla~ //如果x没有被宏定义过，定义x，并编译程序段 1#endif 程序段2blabla~ //如果x已经定义过了则编译程序段2的语句，“忽视”程序段 1 循环引用的后果： 有些头文件重复引用只是增加了编译工作的工作量，不会引起太大的问题，仅仅是编译效率低一些，但是对于大工程而言编译效率低下那将是一件多么痛苦的事情。 有些头文件重复包含，会引起错误，比如在头文件中定义了全局变量(虽然这种方式不被推荐，但确实是C规范允许的)这种会引起重复定义。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile]]></title>
    <url>%2F2019%2F08%2F13%2Folatile%2F</url>
    <content type="text"><![CDATA[介绍：volatile是一个类型修饰符（type specifier）volatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。 volatile和编译器的优化有关：在本次线程内，当读取一个变量时，为了提高读取速度，编译器进行优化时有时会先把变量读取到一个寄存器中；以后，再读取变量值时，就直接从寄存器中读取；当变量值在本线程里改变时，会同时把变量的新值copy到该寄存器中，以保持一致。 当变量因别的线程值发生改变，上面寄存器的值不会相应改变，从而造成应用程序读取的值和实际的变量值不一致。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内联函数]]></title>
    <url>%2F2019%2F08%2F13%2F%E8%81%94%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[函数调用原理：执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈（为此保留的内存块），跳到标记函数起点的内存单元，执行函数代码（也许还需将返回值放入寄存器中），然后跳回到地址被保存的指令处。来回跳跃并记录跳跃位置意味着以前使用函数时，需要一定的开销。 内联函数提供了另一种选择。编译器将使用相应的函数代码替换函数调用。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。1inline double square(double x)&#123;return x*x;&#125; 内联函数与宏定义的区别: 使用宏和内联函数都可以节省在函数调用方面所带来的时间和空间开销。二者都采用了空间换时间的方式，在其调用处进行展开：(1) 在预编译时期，宏定义在调用处执行字符串的原样替换。在编译时期，内联函数在调用处展开，同时进行参数类型检查。(2) 内联函数首先是函数，可以像调用普通函数一样调用内联函数。而宏定义往往需要添加很多括号防止歧义，编写更加复杂。(3) 内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了(无法将this指针放在合适位置)。 可以用内联函数完全替代宏。在编写内联函数时，函数体应该短小而简洁，不应该包含循环等较复杂结构，否则编译器不会将其当作内联函数看待，而是把它决议成为一个静态函数。 有些编译器甚至会优化内联函数，通常为避免一些不必要拷贝和构造，提高工作效率。 频繁的调用内联函数和宏定义容易造成代码膨胀，消耗更大的内存而造成过多的换页操作。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚函数]]></title>
    <url>%2F2019%2F08%2F13%2F%E8%99%9A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[https://blog.csdn.net/zwe7616175/article/details/81334711https://zhidao.baidu.com/question/123304290.html 说明： 使用虚函数，系统会有一定的空间开销。当一个类带有虚函数时，编译系统会为该类构造一个虚函数表（位于类内其他成员前面），是一个指针数组，存放每个虚函数的入口地址。系统在进行动态关联的时间开销很少，提高了多态性的效率。 编译器生成的析构函数都是非虚的，除非是一个子类，其父类有个虚析构函数，此时的虚函数特性继承自基类。有虚函数的类，一般情况下要定义一个虚析构函数。 纯虚函数不能new。 构造函数不能声明为虚函数的原因？ 构造一个对象时，必须知道对象实际类型，而虚函数是在运行期间确定实际类型的。而在构造一个对象时，由于对象还未构造成功，编译器就无法知道对象的实际类型，是该类本身，还是派生类，还是其他。 虚函数的执行依赖于虚函数表，而虚函数表是在构造函数中进行初始化的，即初始化虚表指针（vptr），使得正确指向虚函数表。而在构造对象期间，虚函数表（vtable）还没有被初始化，将无法进行。 什么情况下，类的析构函数应该声明为虚函数？为什么？ 类A中有了虚函数就会在类的数据成员的最前面添加一个vfptr指针(void** vfptr)，这个指针用来指向一个vtable表（一个函数指针数组）（一个类只有一个该表），该表存储着当前类的所有虚函数的地址。这样vfptr就成为了一个类似成员变量的存在。访问虚函数的时候通过vfptr间址找到vtable表，再间址进而找到要调用的函数。这样就在一定程度上摆脱了类型制约。 当B类继承A类的时候，因为A中有虚函数，编译器就自动的给B类添加vfprt指针和vtable表。也可以理解为B类继承来了A类中的那个vptr指针成员。（B对象的vfptr浅拷贝到A对象的vfptr）因此，A对象的vfptr所指向的是B对象的虚函数表，而B的析构函数位于书函数表0的位置，因此，这样就可以通过A类对象的指针d，找到B类对象的析构函数，从而在delete d;时，可以销毁B对象，而不会产生内存泄漏和异常。 简单得来讲：析构函数设为虚函数的原因是为了防止内存泄露。在继承体系中，当基类的指针或引用指向派生类，用基类delete时，如果基类的析构函数没有声明为虚函数，只能析构基类对象，派生类对象将无法析构。因为普通函数受类型的制约，（因为没有vptr指针）使用哪个类的指针调用函数，那么所调用的就是那个累的函数。1234# bug复现a* aa= new b(); // b继承adelete aa;// 打印（执行） a 的析构函数，不执行b的 所以需要将基类的析构函数声明为虚函数，当撤销基类对象的同时也撤销派生类的对象，这个过程是动态关联完成的。 内联函数不能是虚函数 内联函数会在预编译时会进行代码展开，省略函数调用，因此内联函数不能是虚函数。虽然使用inline和virtual共同修饰一个函数时能够通过编译，并在调用时会表现出虚函数的性质，但这是因为编译器在函数声明中遇到virtual关键字时，会选择忽略inline关键字，不进行代码展开。 静态函数不能声明为虚函数 虚函数体现了对象在运行时的多态性，而静态函数属于整个类，不属于某个对象，不能声明为虚函数。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++编译过程]]></title>
    <url>%2F2019%2F08%2F12%2F-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[graph TD classDef className fill:white,stroke:#333,stroke-width:1px; id(预处理,做优化,生成.i文件)-->id1[编译器,生成.s文件] id1[编译器,生成.s文件]-->id2[汇编器,生成.o文件] id2[汇编器,生成.o文件]-->id3[链接器,连接库文件和其他目标文件] id3[链接器,连接库文件和其他目标文件]-->id4(生成可执行文件) class id,id1,id2,id3,id4 className; C++预处理阶段主要完成的工作：处理#开始的预编译指令：（1）宏定义(#define)：对宏定义进行字符串替换。（2）文件包含(#include)：文件包含命令把指定头文件插入该命令行位置取代该命令行，从而把指定的文件和当前的源程序文件连成一个源文件。（3）条件编译(#ifdef)：当满足某条件时语句进行编译，而当条件不满足时则编译另一组语句。条件编译对程序的移植和调试是很有用的。1234567#ifndef Linux linux平台下运行的函数 #else #ifndef windows Windows平台下运行的函数 #endif #endif 汇编阶段：直接生成了汇编代码 链接器阶段（1）函数重载：同名函数，不同函数输入变量/输出变量的类型/不同功能。（2）inline函数：如果函数体不太大，对此函数的所有调用都以函数本体去替代，注意inline只是对编译器的一个建议申请，不是强制命令（3）模板处理：函数定义（包括具现化后的函数模板，类模板的成员函数），变量定义（包括函数模板的静态数据变量，类模板的静态数据变量，类模板的全局对象等）（4）虚函数：每一个多态class都有一份虚函数表，定义或继承了虚函数的对象会有一个隐含成员：指向虚表的指针vptr，在构造或析构对象的时候，编译器生成的代码会修改这个指针。按道理说，一个多态class的虚表应该恰好被一个目标文件定义，这样链接就不会有错，但c++编译器有时无法判断是否应该在当前编译单元生成虚表定义，为保险起见，只能每个编译单元都生成虚表，然后交给链接器来消除重复数据。 C++使用的也是C语言的单遍编译的方式，从头到尾扫描一遍源码，一边解析源码，一边即刻生成目标代码]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 第一段]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[特征工程-特征归一化]]></title>
    <url>%2F2019%2F08%2F06%2F%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B-%E7%89%B9%E5%BE%81%E5%BD%92%E4%B8%80%E5%8C%96%2F</url>
    <content type="text"><![CDATA[为什么要归一化？在实际应用中，通过梯度下降一类的方法需要进行归一化，比如逻辑回归，线性回归，SVM，神经网络，Adaboost，SVM，LR，Knn，KMeans等。但是决策树，朴素贝叶斯，隐马尔可夫等模型不需要归一化。因为前者是基于数值的决策，对单位敏感度高，如果不进行归一化操作可能会导致x/y中有一个变量的影响力$\uparrow$，可能需要更多轮次的迭代才能得到最终解。后者基于交叉熵的信息增益，基于概率分布模型，而概率本身是归一化的（%），所以不需要归一化。 ![upload successful](\images\pasted-1.png) 逻辑回归一定要归一化么？如果你用了L1L2正则的话需要，因为不用正则时，我们的损失函数只是仅仅在度量预测与真实的差距，加上正则后，我们的损失函数除了要度量上面的差距外，还要度量参数值是否足够小。而参数值的大小程度是与特征的数值范围相关的。 归一化的方法 线性函数归一化（适用于简单数值）：$X=\frac{X-X_{min}}{X_{max}-X_{min}}$ 0均值归一化：$z=\frac{x-u}{\sigma}$]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
</search>
